module Sgp4PropMod

use DllMainDll
use EnvConstDll
use TimeFuncDll
use AstroFuncDll
use TleDll
use Sgp4PropDll

implicit none

contains

! Show last logged error message
subroutine ShowErrMsg()
   character(128)  errMsg;

   call GetLastErrMsg(errMsg);
   write(*, '(A, /)') errMsg;
end subroutine ShowErrMsg


! Show last logged error message and exit
subroutine ShowMsgAndTerminate()
   call ShowErrMsg();
   stop;
end subroutine ShowMsgAndTerminate


subroutine FileOpen(fileUnit, fileName)
   integer, intent(in)      :: fileUnit
   character(*), intent(in) :: fileName
   
   integer ioStatus;
   
   open(fileUnit, file=fileName, status='replace', action='write', &
        iostat=ioStatus);
        
   if (ioStatus /= 0) then 
      write (*, *) 'Error: File "' // fileName // '" failed to open.'
      stop
   end if
end subroutine FileOpen



! Print header for the output files
subroutine PrintHeader(fp, infoStr, inFile)
   integer, intent(in) :: fp
   character(*), intent(in) :: infoStr
   character(*), intent(in) :: inFile
   
   integer :: startFrEpoch, stopFrEpoch
   real(8) :: startTime
   real(8) :: stopTime
   real(8) :: stepSize
   character(20) :: dtg20

   write(fp, '(A, //)')    infoStr;
   write(fp, '(A)')   "EPHEMERIS GENERATED BY SGP4 USING THE WGS-72 EARTH MODEL";
   write(fp, '(A)')   "COORDINATE FRAME=TRUE EQUATOR AND MEAN EQUINOX OF EPOCH";
   write(fp, '(A,/)') "USING THE FK5 MEAN OF J2000 TIME AND REFERENCE FRAME";

   write(fp, '(A, A, /)')        "INPUT FILE = ", inFile;

   startFrEpoch = 0
   stopFrEpoch = 0
   startTime = 0
   stopTime = 0
   stepSize = 0

   ! Get prediction control data 
   call Get6P(startFrEpoch, stopFrEpoch, startTime, stopTime, stepSize)

   ! Compute start/stop times - using days since 1950 UTC
   ! user selects start time in minutes since epoch
   if (startFrEpoch == 1) then
      write(fp, '(A, F14.4, A)')    "Start Time = ", startTime, " min from epoch"
   else
      call UTCToDtg20(startTime, dtg20)
      write(fp, '(A, A)')    "Start Time = ", dtg20
   end if
   
   if(stopFrEpoch == 1) then
      write(fp, '(A, F14.4, A)')    "Stop Time  = ", stopTime,  " min from epoch"
   else
      call UTCToDtg20(stopTime, dtg20)
      write(fp, '(A, A)')    "Stop Time  = ", dtg20
   end if
   write(fp, '(A, F14.4, A, /)') "Step size  = ", stepSize,  " min"
   
end subroutine PrintHeader


! Print position and velocity vectors
subroutine PrintPosVel(fp, mse, pos, vel)
   integer, intent(in) :: fp
   real(8), intent(in) :: mse
   real(8), intent(in) :: pos(3)
   real(8), intent(in) :: vel(3)
   
   write(fp, '(" ", 7F17.7)') &
      mse, pos(1:3), vel(1:3);

end subroutine PrintPosVel



! Print osculating Keplerian elements
subroutine PrintOscEls(fp, mse, oscKep)
   integer, intent(in) :: fp
   real(8), intent(in) :: mse
   real(8), intent(in) :: oscKep(6)

   real(8) trueAnomaly;
   
   trueAnomaly = CompTrueAnomaly(oscKep);

   write(fp, '(" ", 7F17.7)') &
      !mse, oscKep(1:5), trueAnomaly;
      ! DHN 23Oct17 - array order was incorrect; fixed it (IssueID# 113)
      mse, oscKep(1:3), oscKep(5:6), trueAnomaly;

end subroutine PrintOscEls


! Print mean Keplerian elements
subroutine PrintMeanEls(fp, mse, meanKep)
   integer, intent(in) :: fp
   real(8), intent(in) :: mse
   real(8), intent(in) :: meanKep(6)

   real(8) meanMotion;  
   
   meanMotion = AToN(meanKep(1));

   write(fp, '(" ", 7F17.7)') &
      mse, meanMotion, meanKep(2), meanKep(3), meanKep(5), meanKep(6), meanKep(4);

end subroutine PrintMeanEls


! Print geodetic latitude longitude altitude and position vector
subroutine PrintLLH(fp, mse, llh, pos)
   integer, intent(in) :: fp
   real(8), intent(in) :: mse
   real(8), intent(in) :: llh(3)
   real(8), intent(in) :: pos(3)
   
   write(fp, '(" ", 7F17.7)') &
      mse, llh(1:3), pos(1:3);
end subroutine PrintLLH

! Print nodal perdiod, apogee, perigee
subroutine PrintNodalApPer(fp, mse, n, nodalApPer)
   integer, intent(in) :: fp
   real(8), intent(in) :: mse
   real(8), intent(in) :: n
   real(8), intent(in) :: nodalApPer(3)

   write(fp, '(" ", 7F17.7)') &
      mse, &
      nodalApPer(1), &
      (1440.0d0 / nodalApPer(1)), &
      n , & 
      1440.0d0 / n, & 
      nodalApPer(2),  &
      nodalApPer(3);
end subroutine PrintNodalApPer

! Calculate start/stop times and step size from 6P card (TimeFunc dll)
subroutine CalcStartStopTime(epoch, tStart, tStop, tStep)
   real(8), intent(in) :: epoch
   real(8), intent(out):: tStart, tStop, tStep
   
   

   integer startFrEpoch, stopFrEpoch
   real(8) startTime, stopTime, stepSize

   startFrEpoch = 0
   stopFrEpoch = 0
   startTime = 0
   stopTime = 0
   stepSize = 0

   ! Get prediction control data 
   call Get6P(startFrEpoch, stopFrEpoch, startTime, stopTime, stepSize)

   ! Compute start/stop times - using days since 1950 UTC
   ! user selects start time in minutes since epoch
   if (startFrEpoch == 1) then
      tStart = epoch + (startTime / 1440)
   else
      tStart = startTime
   end if
   
   ! user selects stop time in minutes since epoch
   if (stopFrEpoch == 1) then
      tStop = epoch + (stopTime / 1440)
   else
      tStop = stopTime
   end if

   tStep = stepSize

end subroutine CalcStartStopTime

end module Sgp4PropMod
   
