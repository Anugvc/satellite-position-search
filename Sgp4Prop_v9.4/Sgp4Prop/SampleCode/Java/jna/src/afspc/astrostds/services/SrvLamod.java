package afspc.astrostds.services;

import java.io.*;

import com.sun.jna.ptr.IntByReference;
import com.sun.jna.ptr.DoubleByReference;

import afspc.astrostds.wrappers.*;
import afspc.astrostds.utilities.Utility;

public class SrvLamod
{

   public static final int
      CARD_1P_FREPOCH = 0,     // Specified time span in minutes since epoch
      CARD_1P_FRDATE = 1;      // Specified time span in UTC  

   // Lamod look mode
   public static final int
      STEPMODE_CULM = 0,
      STEPMODE_STEP = 1,
      STEPMODE_TASK = 2;
         

   // Indexes represent schedule modes
   public static final char
      IDX_SCHED_OBS = 'O',   // Obs schedule mode
      IDX_SCHED_PASS = 'P';  // Pass schedule mode


   public static final String GEN_OBS_FLG [] = {"Do Not Form OBS",
                                                "B3 OBS From Looks",
                                                "Transmission OBS From Looks",
                                                "SP Tasker V obs"};
   public static String [] SEN_OPT_VIS_FLG = {"0- Accept All Passes",
                                              "1- Optical Visible Passes Only",
                                              "2- Passes If Solar Aspect Angle < Max",
                                              "3- Sen In Dark/No Restrctn on Sat (IR sen)",
                                              "","","","","",         /* 4 -> 8 is all null */
                                              "9- Use Limits Record Value"};
   public static final String [] NOSTIC_FLG = {"None",
                                               "Print sen/sat position at each look",
                                               "Print pass-by-pass diagnostics",
                                               "Print sen/sat position and diagnostics"};
   
   public static final double EPSTIMEDAYS = (0.001/1440.0);
   public static final double MINSPERDAY = 1440.0;


   /**
    * <JCL> Function to convert numerical punchObs flag to a string description
    * @param index   The user/application specified index to retrieve the appropriate string
    * @return        The String value at the specified index within GEN_OBS_FLG
    */
   public static String GetPunchObsStr(int index)
   {
      return(GEN_OBS_FLG[index]);
   }

   /**
    * <JCL> Function to convert numerical optical visibility flag to a string description
    * @param index   The user/application specified index to retrieve the appropriate string
    * @return        The String value at the specified index within SEN_OPT_VIS_FLG
    */
   public static String GetVisFlgStr(int index)
   {
      return (SEN_OPT_VIS_FLG[index]);
   }

   /**
    * <JCL> Convert numerical diagnostic mode to a string description
    * @param index   The user/application specified index to retrieve the appropriate string
    * @return        The String value at the specified index within NOSTIC_FLG
    */
   public static String GetDiagModeStr(int index)
   {
      return(NOSTIC_FLG[index]);
   }

   /**
    * <JCL> Print header for sensor/satellite look angles
    * @param outFile       The BufferedWriter object containing the file the header information is printed to
    * @param senKey        The sensor key generated by Lamod
    * @param satKey        The sat key generated by Lamod
    * @param stepModeReq   The requested step mode
    * @param viewType      The Sensor viewing type
    * @param obsType       The Sensor observation type
    * @param optVisFlg     Optical visibility flag
    * @throws IOException
    */
   public static void PrintSenSatHeader(BufferedWriter outFile, long senKey, long satKey, int stepModeReq, byte viewType, byte obsType, int optVisFlg) throws IOException
   {
      // retrieve the step mode being used
      byte [] tempVal = new byte[512];
      JnaLamod.LamodGet1pField(JnaLamod.XF_1P_STEPMODE, tempVal);
      int stepModeUsed = Utility.BytesToInt(tempVal);

      // print the step mode being used
      if (stepModeUsed == STEPMODE_STEP)
      {
         outFile.write(String.format("\n\n+++++ STEP-MODE REQUESTED BY USER +++++\n\n"));
      }
      else if(stepModeUsed == STEPMODE_CULM)
      {
         outFile.write(String.format("\n\n+++++ CULMINATION-MODE REQUESTED BY USER +++++\n\n"));
      }
      else if(stepModeUsed == STEPMODE_TASK)
      {
         outFile.write(String.format("\n\n+++++ Task-MODE REQUESTED BY USER +++++\n\n"));
      }

      // the step mode has been changed from what is requested
      if (stepModeReq != stepModeUsed && stepModeReq == STEPMODE_STEP)
      {
         if (viewType == '9')
         {
            outFile.write(String.format("+++++ STEP-MODE INVOKED FOR ORBITING SENSOR +++++\n\n"));
         }
         else
         {
            outFile.write(String.format("+++++ STEP-MODE INVOKED FOR LARGE PERIOD ORBIT +++++\n\n"));
         }
      }

      tempVal = new byte[512];
      JnaSensor.SensorGetLimField(senKey, JnaSensor.XF_SENLIM_UNIT, tempVal);
      int units = Utility.BytesToInt(tempVal);
      String cun = (units != 0) ? "nm" : "km";
      outFile.write(String.format("LOOK ANGLES FOR SATELLITE %5d%14sSENSOR %3d\n", JnaElOps.SatNumOf(satKey), " ", JnaSensor.SenNumOf(senKey)));
      tempVal = new byte[512];
      JnaSatState.SatStateGetSatDataField(satKey, JnaSatState.XF_SAT_ELSETNUM, tempVal);
      int elsetNum = Utility.BytesToInt(tempVal);
      tempVal = new byte[512];
      JnaSatState.SatStateGetSatDataField(satKey, JnaSatState.XF_SAT_EPOCH, tempVal);
      double ds50UTC = Utility.BytesToDouble(tempVal);
      outFile.write(String.format("EPOCH TIME %s     ELEMENT SET NO.%4d\n", SrvTimeFunc.UTCToDtg20Str(ds50UTC), elsetNum));

      int lineLen;
      if (obsType == '8' || obsType == 'M')
      {
         outFile.write(String.format("TIME                  ELEV    AZ         RNG      RelVel.  OB        SENSOR POSITION\n"));
         outFile.write(String.format("YY DDD HHMM SS.SSS    deg     deg        %2s       km/sec       E km      F km      G km\n", cun));
         lineLen = 91;
      }
      else if (obsType == '9' || obsType == 'O')
      {
         outFile.write(String.format("TIME                  ELEV    AZ         RNG      RelVel. RT.ASCEN.     DECLINATION   SOLAR PHASE I OB        SENSOR POSITION\n"));
         outFile.write(String.format("YY DDD HHMM SS.SSS    deg     deg        %2s       km/sec  HR MN SEC     deg MA SA     ANGLE (deg) L       E km      F km      G km\n", cun));
         lineLen = 132;
      }
      else if (obsType == '5')
      {
         outFile.write(String.format("TIME                  ELEV    AZ         RNG      RNG-RT  RT.ASCEN.     DECLINATION   SOLAR PHASE  I OB\n"));
         outFile.write(String.format("YY DDD HHMM SS.SSS    deg     deg        %2s       %2s/sec  HR MN SEC     deg MA SA     ANGLE (deg)  L   \n", cun, cun));
         lineLen = 103;
      }
      else
      {
         // DHN 15Aug11 - Add azimuth and elevation rates for obsType 4
         if(obsType == '4')
         {
            outFile.write(String.format("TIME                  ELEV    AZ         RNG      RNG-RT   OB   AZ-RT       EL-RT\n"));
            outFile.write(String.format("YY DDD HHMM SS.SSS    deg     deg        %2s       %2s/sec        deg/sec     deg/sec\n", cun, cun));
            lineLen = 85;
         }
         else
         {
            outFile.write(String.format("TIME                  ELEV    AZ         RNG      RNG-RT   OB\n"));
            outFile.write(String.format("YY DDD HHMM SS.SSS    deg     deg        %2s       %2s/sec   \n", cun, cun));
            lineLen = 61;
         }
      }

      String testStr = "";
      for (int i = 0; i < lineLen; i++)
      {
         testStr = testStr + "-";
      }
      
      outFile.write(testStr + "\n");
   }

   /**
    * <JCL> Determine if the current print step is rise: 'r', set: 's', culmination: 'c', pass: 'p', or normal step ' '
    * @param currDs50TAI   Current time in Ds50TAI
    * @param rcs           Rise, Culmination, and Set times for this pass
    * @param interval      Output interval (min)
    * @param stopDs50TAI   Stop time in ds50TAI
    * @return              byte value of the current print step
    */
   public static byte CurrPrintStep(double currDs50TAI, double [] rcs, double interval, double stopDs50TAI)
   {
      byte currStep = ' ';

      if (Math.abs(currDs50TAI - rcs[2]) <= EPSTIMEDAYS)
      {
         currStep = 's';
      }
      else if (Math.abs(currDs50TAI - rcs[1]) <= EPSTIMEDAYS)
      {
         currStep = 'c';
      }
      else if (Math.abs(currDs50TAI - rcs[0]) <= EPSTIMEDAYS)
      {
         currStep = 'r';
      }
      else if (currDs50TAI + (interval / MINSPERDAY) > stopDs50TAI)
      {
         currStep = 'p';
      }
      return currStep;
   }

   /**
    * <JCL> Print one look angle
    * @param outFile       The BufferedWriter object containing the file the header information is printed to
    * @param senSatKey     sen/sat pair key generated by Lamod
    * @param viewType      The Sensor viewing type
    * @param obsType       The Sensor observation type
    * @param optVisFlg     Optical visibility flag 
    * @param currStep      The current step
    * @param lookArr       The look array generated by Lamod LookView
    * @throws IOException
    */
   public static void PrintLook(BufferedWriter outFile,  long senSatKey, byte viewType, byte obsType, int optVisFlg, byte currStep, double [] lookArr) throws IOException
   {
      // Note, sometimes here we're using regular variables, sometimes reference.
      // What it is is that JNA always needs reference,
      // but if we're not using the variables much I don't bother to convert to normal ones for simplicity.
      String cobp;
      double [] cvisd = new double[1];
      byte cvis;
      double [] xlPos = new double[3];
      double azimuth, elevation, range, rangeRate, saa;
      double [] relvel = new double[1];
      double [] dvel = new double[3];
      double ds50UTC;
      DoubleByReference rasc = new DoubleByReference();
      DoubleByReference decl = new DoubleByReference();
      IntByReference irahr = new IntByReference();
      IntByReference iramn = new IntByReference();
      IntByReference idecdg = new IntByReference();
      IntByReference idecmn = new IntByReference();
      DoubleByReference xrasc = new DoubleByReference();
      DoubleByReference xdecsc = new DoubleByReference();
      String currTimeStr;
      double [] angArr = new double[5];
      String decSignStr;
      double [] azElRates = new double[2];

      ds50UTC = lookArr[JnaLamod.XA_LOOK_DS50UTC];
      elevation   = lookArr[JnaLamod.XA_LOOK_ELEV];

      // Avoid printing -0.000
      if(PrintAsZero(elevation))
      {
         elevation = 0.0;
      }

      azimuth   = lookArr[JnaLamod.XA_LOOK_AZIM];
      range  = lookArr[JnaLamod.XA_LOOK_RNG];
      rangeRate  = lookArr[JnaLamod.XA_LOOK_RNGRT];

      // Avoid printing -0.000
      if(PrintAsZero(rangeRate))
      {
         rangeRate = 0.0;
      }

      JnaLamod.LamodGetViewDataField(senSatKey, JnaLamod.XF_VIEW_RELVEL, relvel);
      JnaLamod.LamodGetViewDataField(senSatKey, JnaLamod.XF_VIEW_ANGARR, angArr);
      saa = angArr[JnaLamod.XA_ANGLE_SOLARASPECT];

      if (obsType == '5' || obsType == '9' || obsType == 'O')
      {
         JnaLamod.LamodGetViewDataField(senSatKey, JnaLamod.XF_VIEW_RUVEC, xlPos);

         JnaLamod.LamodCompRaDec(xlPos, rasc, decl, irahr, iramn, xrasc, idecdg, idecmn, xdecsc);
         if (idecdg.getValue() == 0 && decl.getValue() < 0.0)
         {
            decSignStr = "-0";
         }
         else
         {
            decSignStr = String.format("%03d", idecdg.getValue());
         }
      }

      JnaLamod.LamodGetViewDataField(senSatKey, JnaLamod.XF_VIEW_CVIS, cvisd);
      cvis = (byte) cvisd[0];

      cobp = "  ";

      currTimeStr = SrvTimeFunc.UTCToDtg18Str(ds50UTC);

      if (obsType == '8' || obsType == 'M')
      {
         JnaLamod.LamodGetViewDataField(senSatKey, JnaLamod.XF_VIEW_SENEFG, dvel);
         outFile.write(String.format("%20s  %7.3f  %7.3f %10.3f %8.4f  %2s %10.3f%10.3f%10.3f\n", currTimeStr, elevation, azimuth, range, relvel[0], cobp, dvel[0], dvel[1], dvel[2]));
      }
      else if (obsType == '9' || obsType == 'O')
      {
         JnaLamod.LamodGetViewDataField(senSatKey, JnaLamod.XF_VIEW_SENEFG, dvel);
         outFile.write(String.format("%18s  %7.3f  %7.3f %10.3f %8.3f  %2d %2d %6.3f  %3d %2d %5.2f   %8.3f  %c%c %2s%10.3f%10.3f%10.3f\n",
            currTimeStr, elevation, azimuth, range, relvel[0], irahr.getValue(), iramn.getValue(), xrasc.getValue(), idecdg.getValue(), idecmn.getValue(), xdecsc.getValue(),
            saa, ' ', cvis, cobp, dvel[0], dvel[1], dvel[2]));
      }
      else if (obsType == '5')
      {
         outFile.write(String.format("%s  %7.3f  %7.3f %10.3f %8.3f  %2d %2d %6.3f  %3d %2d %5.2f %c %8.3f    %c %2s\n",
         currTimeStr, elevation, azimuth, range, rangeRate, irahr.getValue(), iramn.getValue(), xrasc.getValue(), idecdg.getValue(), idecmn.getValue(),
         xdecsc.getValue(), currStep, saa, cvis, cobp));
      }
      // DHN 15Aug11 - Add azimuth and elevation rates for obsType 4
      // <JCL> Rewrote this to be a single else if followed by else instead of nesting
      else if(obsType == '4')
      {
         JnaLamod.LamodGetViewDataField(senSatKey, JnaLamod.XF_VIEW_AZELRATES, azElRates);
         outFile.write(String.format("%s  %7.3f  %7.3f %10.3f %8.3f %c %2s  %10.7f  %10.7f\n", currTimeStr, elevation, azimuth, range, rangeRate, currStep, cobp, azElRates[0], azElRates[1]));
      }
      else
      {
         outFile.write(String.format("%s  %7.3f  %7.3f %10.3f %8.3f %c %2s\n", currTimeStr, elevation, azimuth, range, rangeRate, currStep, cobp));
      }
   }

   /**
    * Print the summary of the current step
    * @param outFile    The BufferedWriter object containing the file the header information is printed to
    * @param senNum     The input sensor number
    * @param satNum     The input satellite number
    * @param numLooks   The number of valid looks
    * @param numPasses  The number of possible passes Special values: -1: The senSatKey is invalid, 0: culmination mode wasn't selected
    * @throws IOException
    */
   public static void PrintSummary(BufferedWriter outFile, int senNum, int satNum, int numLooks, int numPasses) throws IOException
   {
      outFile.write(String.format("      SUMMARY FOR SATELLITE %5d and SENSOR %03d:\n", satNum, senNum));
      outFile.write("      ------------------------------------------\n");
      if (numLooks == 0)
      {
         outFile.write("      *** NO LOOK ANGLES FOUND ***\n");
      }
      else
      {
         outFile.write(String.format("      %6d look angle(s) printed\n", numLooks));
         outFile.write(String.format("        %4d pass(es) computed\n", numPasses));
      }
      outFile.write("      ------------------------------------------\n\n\n");
   }

   /**
    * <JCL> Print generated obs to file
    * @param outFile    The BufferedWriter object containing the file the header information is printed to
    * @param senSatKey  sen/sat pair key generated by Lamod
    * @param punchObs   Flag to generate obs from look angles: 0=Do not form obs, 1=Form B3 obs from look angles, 2=Form TTY obs from look angles
    * @throws IOException
    */
   public static void PrintObs(BufferedWriter outFile, long senSatKey, int punchObs) throws IOException
   {
      // retrieve obs in the format requested
      byte [] obsLine1 = new byte[Utility.INPUTCARDLEN];
      byte [] obsLine2 = new byte[Utility.INPUTCARDLEN];
      IntByReference numLines = new IntByReference();
      JnaLamod.LamodGenObs(senSatKey, punchObs, 'U', obsLine1, obsLine2, numLines);

      // write to the output file
      outFile.write(Utility.BytesToString(obsLine1).trim() + "\n");
      if (numLines.getValue() == 2)
      {
         outFile.write(Utility.BytesToString(obsLine2).trim() + "\n");
      }
   }

   /**
    * <JCL> Determine if the input value is small enough to be displayed as 0.000 instead of -0.000
    * @param intValue   The initial value
    * @return           True if number is small enough to be displayed as 0.000
    */
   public static boolean PrintAsZero(double intValue)
   {
      return (Math.abs(intValue * 10000.0) < 5.0 ? true : false);
   }

   /**
    * Additional call for printing obs with data input by application
    * @param outFile    The BufferedWriter object containing the file the header information is printed to
    * @param obsLine1   First line of the formatted obs strings
    * @param obsLine2   Second line, if available, of the formatted obs strings
    * @param numLines   Number of lines of the output strings
    * @throws IOException
    */
   public static void PrintObsSsnam(BufferedWriter outFile, byte[] obsLine1, byte[] obsLine2, int numLines) throws IOException
   {
      // retrieve obs in the format requested
      //byte [] obsLine1 = new byte[Utility.INPUTCARDLEN];
      //byte [] obsLine2 = new byte[Utility.INPUTCARDLEN];
      //IntByReference numLines = new IntByReference();
      //LamodGenObs(senSatKey, punchObs, 'U', obsLine1, obsLine2, numLines);

      // write to the output file
      outFile.write(Utility.BytesToString(obsLine1).trim() + "\n");
      if (numLines == 2)
      {
         outFile.write(Utility.BytesToString(obsLine2).trim() + "\n");
      }
   }

   /**
    * Print diagnostic information
    * @param outFile    A BufferedWriter with the file to write to
    * @param senSatKey  The senSatKey generated by the Lamod DLL
    * @param viewType   byte parameter holding the viewtype
    * @param nosticFlg  The diagnostic mode determined by Lamod pCard
    * @param lookArr    double array carrying results from the LamodComputeLookView method call
    * @param lookCode   The code determining the validity of the look angle
    * @throws IOException
    */
   public static void PrintNosticData(BufferedWriter outFile, int senNum, int satNum, char viewType, int nosticFlg, double[] lookArr, int lookCode) throws IOException
   {
      // DHN 19May11 - Only print pass by pass nostic if nostic flag >= 2
      if (nosticFlg >= 2)
      {
         // Print sensor/satellite number at each step
         outFile.write("");
         outFile.write(String.format("   >>> Sensor: %3d - Satellite: %6d - Time: %20s - Mse: %14.6f\n", senNum,
                  satNum, SrvTimeFunc.UTCToDtg20Str(lookArr[JnaLamod.XA_LV_DS50UTC]), lookArr[JnaLamod.XA_LV_MSE]));

         if (lookCode == 0)
            outFile.write("    +++ The sensor/satellite PASSED all limit tests +++\n");
         else if (lookCode == 1)
            outFile.write("    --- The sensor/satellite FAILED horizon break test ---\n");
         else
         {
            //check for ground-based optical illumination: sat must be in sunlight & sensor in darkness
            if ((char)((int)lookArr[JnaLamod.XA_LV_VIS]) == 'N')
               outFile.write("    --- The sensor/satellite FAILED illumination test (sensor isn't in darkness & sensor isn't sunlit)---\n");
            else if ((char)((int)lookArr[JnaLamod.XA_LV_VIS]) == 'A')
               outFile.write("    --- The sensor/satellite FAILED illumination test (satellite isn't sunlit)---\n");
            else if ((char)((int)lookArr[JnaLamod.XA_LV_VIS]) == 'E')
               outFile.write("    --- The sensor/satellite FAILED illumination test (sensor isn't in darkness)---\n");
            PrintPassByPassNostic(outFile, viewType, lookArr);
         }
      }

      // Print sensor/satellite position at each look if requested
      if (lookCode == 0 && (nosticFlg == 1 || nosticFlg == 3))
         PrintSenSatPosition(outFile, viewType, lookArr);
   }

   /**
    * Print pass-by-pass diagnostics
    * @param outFile    A BufferedWriter with the file to write to
    * @param viewType   byte parameter holding the viewtype
    * @param lookArr    double array carrying results from the LamodComputeLookView method call
    * @throws IOException
    */
   public static void PrintPassByPassNostic(BufferedWriter outFile, char viewType, double[] lookArr) throws IOException
   {
      String msgStrFormat = "    --- The sensor/satellite FAILED %s test ---\n";

      // check for failed range limits
      if ((int)lookArr[JnaLamod.XA_LV_MINRANGE] == 0)
         outFile.write(String.format(msgStrFormat, "minimum range"));

      if ((int)lookArr[JnaLamod.XA_LV_MAXRANGE] == 0)
         outFile.write(String.format(msgStrFormat, "max range"));

   /*
   // visibility checks: earth-based sensors...
   if (limFlgArr[XA_LIMFLG_Visual] == 0)
   fprintf(fp, msgStrFormat, "illumination");
   */


      // orbiting sensors: check for eclipse conditions
      if (viewType == '9')
         if ((int)lookArr[JnaLamod.XA_LV_UMBECLIP] == 0)
            outFile.write(String.format(msgStrFormat, "umbral eclipse"));
         else if ((int)lookArr[JnaLamod.XA_LV_PENECLIP] == 0)
            outFile.write(String.format(msgStrFormat, "penum. eclipse"));

      // pass failed sensor azimuth limit
      if ((int)lookArr[JnaLamod.XA_LV_AZLIM] == 0)
         outFile.write(String.format(msgStrFormat, "azimuth/ra limit"));

      // pass failed sensor el limit
      if ((int)lookArr[JnaLamod.XA_LV_ELLIM] == 0)
         outFile.write(String.format(msgStrFormat, "el/dec limit"));


      // pass failed solar aspect angle test
      if ((int)lookArr[JnaLamod.XA_LV_SAALIM] == 0)
         outFile.write(String.format(msgStrFormat, "solar aspect angle"));

      // pass failed range-rate/relative velocity limit
      if ((int)lookArr[JnaLamod.XA_LV_RVELLIM] == 0)
         outFile.write(String.format(msgStrFormat, "rge-rt/rel-vel limit"));

      // for sat-to-sat, check for planetary obstructions: earth first
      //!CVIS2 = " "
      if ((int)lookArr[JnaLamod.XA_LV_EARTHOB] == 0)
         outFile.write(String.format(msgStrFormat, "earth obstruction"));
      else if ((int)lookArr[JnaLamod.XA_LV_EARTHBK] == 0)
         outFile.write(String.format(msgStrFormat, "earth in background"));
      //!else
      //   CVIS2 = "E"

      // ..., check for sun too close to observed satellite
      if ((int)lookArr[JnaLamod.XA_LV_SOLEXCL] == 0)
         outFile.write(String.format(msgStrFormat, "solar exclusion"));

      // ...finally, check for moon too close to observation
      if ((int)lookArr[JnaLamod.XA_LV_LUNEXCL] == 0)
         outFile.write(String.format(msgStrFormat, "lunar exclusion"));

      //// for optical ground, check for moon too close to observation 10DEC04
      //if (limFlgArr[XA_LIMFLG_LUNEXCL] == 0)
      //   fprintf(fp, msgStrFormat, "lunar exclusion");
   }

   /**
    * Print sensor/satellite positions at the time look is computed
    * @param outFile    BufferedWriter with the file to write to
    * @param viewType   a byte parameter holding the viewType
    * @param lookArr         double array carrying results from the LamodComputeLookView method call
    * @throws IOException
    */
   public static void PrintSenSatPosition(BufferedWriter outFile, char viewType, double[] lookArr) throws IOException
   {
      outFile.write(String.format("    Sensor Position: X   =%10.3f km;  Y   =%10.3f km;  Z   =%10.3f km \n", lookArr[JnaLamod.XA_LV_SENPOSX], lookArr[JnaLamod.XA_LV_SENPOSY], lookArr[JnaLamod.XA_LV_SENPOSZ]));
      outFile.write(String.format("           Velocity: XD  =%10.5f k/s; YD  =%10.5f k/s; ZD  =%10.5f k/s\n", lookArr[JnaLamod.XA_LV_SENVELX], lookArr[JnaLamod.XA_LV_SENVELY], lookArr[JnaLamod.XA_LV_SENVELZ]));
      outFile.write(String.format("           Geod    : nLat=%10.5f deg; eLon=%10.5f deg; Hght=%10.3f km \n", lookArr[JnaLamod.XA_LV_SENLAT], lookArr[JnaLamod.XA_LV_SENLON], lookArr[JnaLamod.XA_LV_SENHEIGHT]));
      outFile.write(String.format("    Sat Position   : X   =%10.3f km;  Y   =%10.3f km;  Z   =%10.3f km \n", lookArr[JnaLamod.XA_LV_SATPOSX], lookArr[JnaLamod.XA_LV_SATPOSY], lookArr[JnaLamod.XA_LV_SATPOSZ]));
      outFile.write(String.format("        Velocity   : XD  =%10.5f k/s; YD  =%10.5f k/s; ZD  =%10.5f k/s\n", lookArr[JnaLamod.XA_LV_SATVELX], lookArr[JnaLamod.XA_LV_SATVELY], lookArr[JnaLamod.XA_LV_SATVELZ]));
      outFile.write(String.format("        Geod       : nLat=%10.5f deg; eLon=%10.5f deg; Hght=%10.3f km \n", lookArr[JnaLamod.XA_LV_SATLAT], lookArr[JnaLamod.XA_LV_SATLON], lookArr[JnaLamod.XA_LV_SATHEIGHT]));


      // For orbiting sensors
      if (viewType == '9')
      {
         outFile.write(String.format("    Solar Unit Vec : X   =%14.8f      Y   =%14.8f      Z   =%14.8f    \n", lookArr[JnaLamod.XA_LV_USUNX], lookArr[JnaLamod.XA_LV_USUNY], lookArr[JnaLamod.XA_LV_USUNZ]));
         outFile.write(String.format("    Lunar Unit Vec : X   =%14.8f      Y   =%14.8f      Z   =%14.8f    \n", lookArr[JnaLamod.XA_LV_UMOONX], lookArr[JnaLamod.XA_LV_UMOONY], lookArr[JnaLamod.XA_LV_UMOONZ]));
         outFile.write(String.format("    Angles (deg): Sun/sen/sat =%8.3f; Sun/earth/sat =%8.3f; Sun/earth/sen =%8.3f; Moon/sen/sat =%8.3f\n",
                 lookArr[JnaLamod.XA_LV_SUSESA], lookArr[JnaLamod.XA_LV_SUEASA], lookArr[JnaLamod.XA_LV_SUEASE], lookArr[JnaLamod.XA_LV_MOSESA]));

         if (lookArr[JnaLamod.XA_LV_NBORE1] > 0)
         {
            outFile.write(String.format("    Off-boresight & clock angles (#1) =%8.3f & %8.3f deg\n",
                    lookArr[JnaLamod.XA_LV_OBEL1], lookArr[JnaLamod.XA_LV_OBAZ1]));

            if (lookArr[JnaLamod.XA_LV_NBORE2] > 0 && lookArr[JnaLamod.XA_LV_NBORE2] < 7)
               outFile.write(String.format("    Off-boresight & clock angles (#2) =%8.3f & %8.3f deg\n",
                       lookArr[JnaLamod.XA_LV_OBEL2], lookArr[JnaLamod.XA_LV_OBAZ2]));
         }
      }
      outFile.write("\n");
   }

}


